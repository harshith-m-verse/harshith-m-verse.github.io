{"version":3,"file":"utility-fetchutils.b83b97cb.bundle.js","mappings":"6PAAA,e,ohCAQA,IAGIA,EAAqB,GAErBC,EAAsB,+CAAG,WAAeC,GAAf,6FACvBC,EAAoB,GACpBC,EAAgB,GAChBC,EAAa,GACbC,EAAW,GAJY,IAMRJ,GANQ,6DAOH,KADhBK,EANmB,SAOdC,UAAuC,IAApBN,EAAWO,OAPhB,qBAQpBT,EAAmBU,eAAeC,KAAKJ,EAAQK,cAR3B,oBASgC,OAAlDZ,EAAmBW,KAAKJ,EAAQK,cATd,wBAWnBN,EAASC,EAAQM,UAAYb,EAAmBW,KAAKJ,EAAQK,cAX1C,yDAgBZ,IAAIE,SAAQ,SAAAC,GAAO,OAAIC,YAAU,6BAAC,0GAClBf,EAAuBC,GADL,OACjCe,EADiC,OAErCF,EAAQE,GAF6B,2CAGrC,QAnBe,gCAyBrBZ,EAAWa,KAAKX,GAChBP,EAAmBW,KAAKJ,EAAQK,cAAgB,KA1B3B,QA6BzBT,EAAkBe,KAAKX,EAAQM,UAC/BT,EAAcc,KAAaC,EAAAA,QAAMC,IAAIb,EAAQK,YAAa,CAACS,kBAAiBd,EAAQK,YAAYU,SAAS,2BAnCtFC,MAAK,SAAAC,GAAC,MAAK,CAACP,OAAOO,EAAGC,OAAQ,gBACzB,SAAAC,GAAC,MAAK,CAACT,OAAOS,EAAGD,OAAQ,gBAIxB,0KAiCVX,QAAQa,IAAIvB,GAjCF,QAiCzBa,EAjCyB,0DAmCzBW,QAAQC,IAAI,QAAZ,MAnCyB,QAqC3B,IAAQC,EAAE,EAAGA,EAAIb,EAAOR,OAAQqB,IAC9BxB,EAASH,EAAkB2B,IAAMb,EAAOa,GAtCf,OAwC3BzB,EAAW0B,SAAQ,SAAAxB,GAAO,OAAIP,EAAmBW,KAAKJ,EAAQK,cAAgBN,EAASC,EAAQM,aAxCpE,kBAyCpBP,GAzCoB,wEAAH,sD","sources":["webpack://1at06cs097/./utility/fetchUtils.js"],"sourcesContent":["import axios from 'axios';\n// import {performance} from 'perf_hooks';\n\n// function executingAt(startTime) {\n//     return (performance.now() - startTime) / 1000;\n//   }\n  \n\nconst reflect = p => p.then(v => ({result:v, status: \"fulfilled\" }),\n                            e => ({result:e, status: \"rejected\" }));\n\nlet clientSideAPICache = {};\n\nlet parallelDataStoreFetch = async function(datastores) {\n  let promisesEndpoints = [];\n  let promisesArray = [];\n  let tobeCached = [];\n  let toReturn = {};\n  let result;\n  for(let element of datastores){\n    if(element.useCache===true && datastores.length===1){\n      if(clientSideAPICache.hasOwnProperty(btoa(element.endpointurl))){\n        if(clientSideAPICache[btoa(element.endpointurl)] !== null){\n          // console.log(\"Cache found. So skipping API call for \" + element.endpoint);\n          toReturn[element.endpoint] = clientSideAPICache[btoa(element.endpointurl)];\n          continue;\n        }\n        else{\n          // console.log(\"Cache key found. But response not available yet for \" + element.endpoint);\n          return new Promise(resolve => setTimeout(async function(){\n              let result = await parallelDataStoreFetch(datastores);\n              resolve(result);\n            },50)\n          );\n        }\n      }\n      else{\n        // console.log(element.endpoint + \" will be cached this time\")\n        tobeCached.push(element);\n        clientSideAPICache[btoa(element.endpointurl)] = null;\n      }\n    }\n    promisesEndpoints.push(element.endpoint);\n    promisesArray.push(reflect(axios.get(element.endpointurl, {withCredentials: element.endpointurl.includes(\"api-news.dailyhunt.in\")? true : false})));\n  };\n  try{\n    result = await Promise.all(promisesArray);\n  }catch(e) {\n    console.log(\"Error\", e);\n  }\n  for(let i=0; i < result.length; i++) {\n    toReturn[promisesEndpoints[i]] = result[i];\n  }\n  tobeCached.forEach(element => clientSideAPICache[btoa(element.endpointurl)] = toReturn[element.endpoint]);\n  return toReturn;\n}\n\nexport {parallelDataStoreFetch};"],"names":["clientSideAPICache","parallelDataStoreFetch","datastores","promisesEndpoints","promisesArray","tobeCached","toReturn","element","useCache","length","hasOwnProperty","btoa","endpointurl","endpoint","Promise","resolve","setTimeout","result","push","axios","get","withCredentials","includes","then","v","status","e","all","console","log","i","forEach"],"sourceRoot":""}