{"version":3,"file":"vendors-mobx-react-lite.834337b8.bundle.js","mappings":"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","sources":["webpack://1at06cs097/./node_modules/mobx-react-lite/es/utils/assertEnvironment.js","webpack://1at06cs097/./node_modules/mobx-react-lite/es/utils/observerBatching.js","webpack://1at06cs097/./node_modules/mobx-react-lite/es/utils/printDebugValue.js","webpack://1at06cs097/./node_modules/mobx-react-lite/es/utils/FinalizationRegistryWrapper.js","webpack://1at06cs097/./node_modules/mobx-react-lite/es/utils/reactionCleanupTrackingCommon.js","webpack://1at06cs097/./node_modules/mobx-react-lite/es/utils/createTimerBasedReactionCleanupTracking.js","webpack://1at06cs097/./node_modules/mobx-react-lite/es/utils/reactionCleanupTracking.js","webpack://1at06cs097/./node_modules/mobx-react-lite/es/utils/createReactionCleanupTrackingUsingFinalizationRegister.js","webpack://1at06cs097/./node_modules/mobx-react-lite/es/staticRendering.js","webpack://1at06cs097/./node_modules/mobx-react-lite/es/useObserver.js","webpack://1at06cs097/./node_modules/mobx-react-lite/es/observer.js","webpack://1at06cs097/./node_modules/mobx-react-lite/es/ObserverComponent.js","webpack://1at06cs097/./node_modules/mobx-react-lite/es/useLocalObservable.js","webpack://1at06cs097/./node_modules/mobx-react-lite/es/useAsObservableSource.js","webpack://1at06cs097/./node_modules/mobx-react-lite/es/useLocalStore.js","webpack://1at06cs097/./node_modules/mobx-react-lite/es/index.js"],"sourcesContent":["import { makeObservable } from \"mobx\";\nimport { useState } from \"react\";\nif (!useState) {\n    throw new Error(\"mobx-react-lite requires React with Hooks support\");\n}\nif (!makeObservable) {\n    throw new Error(\"mobx-react-lite@3 requires mobx at least version 6 to be available\");\n}\n//# sourceMappingURL=assertEnvironment.js.map","import { configure } from \"mobx\";\nexport function defaultNoopBatch(callback) {\n    callback();\n}\nexport function observerBatching(reactionScheduler) {\n    if (!reactionScheduler) {\n        reactionScheduler = defaultNoopBatch;\n        if (\"production\" !== process.env.NODE_ENV) {\n            console.warn(\"[MobX] Failed to get unstable_batched updates from react-dom / react-native\");\n        }\n    }\n    configure({ reactionScheduler: reactionScheduler });\n}\nexport var isObserverBatched = function () {\n    if (\"production\" !== process.env.NODE_ENV) {\n        console.warn(\"[MobX] Deprecated\");\n    }\n    return true;\n};\n//# sourceMappingURL=observerBatching.js.map","import { getDependencyTree } from \"mobx\";\nexport function printDebugValue(v) {\n    return getDependencyTree(v);\n}\n//# sourceMappingURL=printDebugValue.js.map","var FinalizationRegistryLocal = typeof FinalizationRegistry === \"undefined\" ? undefined : FinalizationRegistry;\nexport { FinalizationRegistryLocal as FinalizationRegistry };\n//# sourceMappingURL=FinalizationRegistryWrapper.js.map","export function createTrackingData(reaction) {\n    var trackingData = {\n        reaction: reaction,\n        mounted: false,\n        changedBeforeMount: false,\n        cleanAt: Date.now() + CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS\n    };\n    return trackingData;\n}\n/**\n * The minimum time before we'll clean up a Reaction created in a render\n * for a component that hasn't managed to run its effects. This needs to\n * be big enough to ensure that a component won't turn up and have its\n * effects run without being re-rendered.\n */\nexport var CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS = 10000;\n/**\n * The frequency with which we'll check for leaked reactions.\n */\nexport var CLEANUP_TIMER_LOOP_MILLIS = 10000;\n//# sourceMappingURL=reactionCleanupTrackingCommon.js.map","var __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport { CLEANUP_TIMER_LOOP_MILLIS, createTrackingData } from \"./reactionCleanupTrackingCommon\";\n/**\n * timers, gc-style, uncommitted reaction cleanup\n */\nexport function createTimerBasedReactionCleanupTracking() {\n    /**\n     * Reactions created by components that have yet to be fully mounted.\n     */\n    var uncommittedReactionRefs = new Set();\n    /**\n     * Latest 'uncommitted reactions' cleanup timer handle.\n     */\n    var reactionCleanupHandle;\n    /* istanbul ignore next */\n    /**\n     * Only to be used by test functions; do not export outside of mobx-react-lite\n     */\n    function forceCleanupTimerToRunNowForTests() {\n        // This allows us to control the execution of the cleanup timer\n        // to force it to run at awkward times in unit tests.\n        if (reactionCleanupHandle) {\n            clearTimeout(reactionCleanupHandle);\n            cleanUncommittedReactions();\n        }\n    }\n    /* istanbul ignore next */\n    function resetCleanupScheduleForTests() {\n        var e_1, _a;\n        if (uncommittedReactionRefs.size > 0) {\n            try {\n                for (var uncommittedReactionRefs_1 = __values(uncommittedReactionRefs), uncommittedReactionRefs_1_1 = uncommittedReactionRefs_1.next(); !uncommittedReactionRefs_1_1.done; uncommittedReactionRefs_1_1 = uncommittedReactionRefs_1.next()) {\n                    var ref = uncommittedReactionRefs_1_1.value;\n                    var tracking = ref.current;\n                    if (tracking) {\n                        tracking.reaction.dispose();\n                        ref.current = null;\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (uncommittedReactionRefs_1_1 && !uncommittedReactionRefs_1_1.done && (_a = uncommittedReactionRefs_1.return)) _a.call(uncommittedReactionRefs_1);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            uncommittedReactionRefs.clear();\n        }\n        if (reactionCleanupHandle) {\n            clearTimeout(reactionCleanupHandle);\n            reactionCleanupHandle = undefined;\n        }\n    }\n    function ensureCleanupTimerRunning() {\n        if (reactionCleanupHandle === undefined) {\n            reactionCleanupHandle = setTimeout(cleanUncommittedReactions, CLEANUP_TIMER_LOOP_MILLIS);\n        }\n    }\n    function scheduleCleanupOfReactionIfLeaked(ref) {\n        uncommittedReactionRefs.add(ref);\n        ensureCleanupTimerRunning();\n    }\n    function recordReactionAsCommitted(reactionRef) {\n        uncommittedReactionRefs.delete(reactionRef);\n    }\n    /**\n     * Run by the cleanup timer to dispose any outstanding reactions\n     */\n    function cleanUncommittedReactions() {\n        reactionCleanupHandle = undefined;\n        // Loop through all the candidate leaked reactions; those older\n        // than CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS get tidied.\n        var now = Date.now();\n        uncommittedReactionRefs.forEach(function (ref) {\n            var tracking = ref.current;\n            if (tracking) {\n                if (now >= tracking.cleanAt) {\n                    // It's time to tidy up this leaked reaction.\n                    tracking.reaction.dispose();\n                    ref.current = null;\n                    uncommittedReactionRefs.delete(ref);\n                }\n            }\n        });\n        if (uncommittedReactionRefs.size > 0) {\n            // We've just finished a round of cleanups but there are still\n            // some leak candidates outstanding.\n            ensureCleanupTimerRunning();\n        }\n    }\n    return {\n        addReactionToTrack: function (reactionTrackingRef, reaction, \n        /**\n         * On timer based implementation we don't really need this object,\n         * but we keep the same api\n         */\n        objectRetainedByReact) {\n            reactionTrackingRef.current = createTrackingData(reaction);\n            scheduleCleanupOfReactionIfLeaked(reactionTrackingRef);\n            return reactionTrackingRef.current;\n        },\n        recordReactionAsCommitted: recordReactionAsCommitted,\n        forceCleanupTimerToRunNowForTests: forceCleanupTimerToRunNowForTests,\n        resetCleanupScheduleForTests: resetCleanupScheduleForTests\n    };\n}\n//# sourceMappingURL=createTimerBasedReactionCleanupTracking.js.map","import { FinalizationRegistry as FinalizationRegistryMaybeUndefined } from \"./FinalizationRegistryWrapper\";\nimport { createReactionCleanupTrackingUsingFinalizationRegister } from \"./createReactionCleanupTrackingUsingFinalizationRegister\";\nimport { createTimerBasedReactionCleanupTracking } from \"./createTimerBasedReactionCleanupTracking\";\nvar _a = FinalizationRegistryMaybeUndefined\n    ? createReactionCleanupTrackingUsingFinalizationRegister(FinalizationRegistryMaybeUndefined)\n    : createTimerBasedReactionCleanupTracking(), addReactionToTrack = _a.addReactionToTrack, recordReactionAsCommitted = _a.recordReactionAsCommitted, resetCleanupScheduleForTests = _a.resetCleanupScheduleForTests, forceCleanupTimerToRunNowForTests = _a.forceCleanupTimerToRunNowForTests;\nexport { addReactionToTrack, recordReactionAsCommitted, resetCleanupScheduleForTests, forceCleanupTimerToRunNowForTests };\n//# sourceMappingURL=reactionCleanupTracking.js.map","import { createTrackingData } from \"./reactionCleanupTrackingCommon\";\n/**\n * FinalizationRegistry-based uncommitted reaction cleanup\n */\nexport function createReactionCleanupTrackingUsingFinalizationRegister(FinalizationRegistry) {\n    var cleanupTokenToReactionTrackingMap = new Map();\n    var globalCleanupTokensCounter = 1;\n    var registry = new FinalizationRegistry(function cleanupFunction(token) {\n        var trackedReaction = cleanupTokenToReactionTrackingMap.get(token);\n        if (trackedReaction) {\n            trackedReaction.reaction.dispose();\n            cleanupTokenToReactionTrackingMap.delete(token);\n        }\n    });\n    return {\n        addReactionToTrack: function (reactionTrackingRef, reaction, objectRetainedByReact) {\n            var token = globalCleanupTokensCounter++;\n            registry.register(objectRetainedByReact, token, reactionTrackingRef);\n            reactionTrackingRef.current = createTrackingData(reaction);\n            reactionTrackingRef.current.finalizationRegistryCleanupToken = token;\n            cleanupTokenToReactionTrackingMap.set(token, reactionTrackingRef.current);\n            return reactionTrackingRef.current;\n        },\n        recordReactionAsCommitted: function (reactionRef) {\n            registry.unregister(reactionRef);\n            if (reactionRef.current && reactionRef.current.finalizationRegistryCleanupToken) {\n                cleanupTokenToReactionTrackingMap.delete(reactionRef.current.finalizationRegistryCleanupToken);\n            }\n        },\n        forceCleanupTimerToRunNowForTests: function () {\n            // When FinalizationRegistry in use, this this is no-op\n        },\n        resetCleanupScheduleForTests: function () {\n            // When FinalizationRegistry in use, this this is no-op\n        }\n    };\n}\n//# sourceMappingURL=createReactionCleanupTrackingUsingFinalizationRegister.js.map","var globalIsUsingStaticRendering = false;\nexport function enableStaticRendering(enable) {\n    globalIsUsingStaticRendering = enable;\n}\nexport function isUsingStaticRendering() {\n    return globalIsUsingStaticRendering;\n}\n//# sourceMappingURL=staticRendering.js.map","var __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { Reaction } from \"mobx\";\nimport React from \"react\";\nimport { printDebugValue } from \"./utils/printDebugValue\";\nimport { addReactionToTrack, recordReactionAsCommitted } from \"./utils/reactionCleanupTracking\";\nimport { isUsingStaticRendering } from \"./staticRendering\";\nfunction observerComponentNameFor(baseComponentName) {\n    return \"observer\" + baseComponentName;\n}\n/**\n * We use class to make it easier to detect in heap snapshots by name\n */\nvar ObjectToBeRetainedByReact = /** @class */ (function () {\n    function ObjectToBeRetainedByReact() {\n    }\n    return ObjectToBeRetainedByReact;\n}());\nfunction objectToBeRetainedByReactFactory() {\n    return new ObjectToBeRetainedByReact();\n}\nexport function useObserver(fn, baseComponentName) {\n    if (baseComponentName === void 0) { baseComponentName = \"observed\"; }\n    if (isUsingStaticRendering()) {\n        return fn();\n    }\n    var _a = __read(React.useState(objectToBeRetainedByReactFactory), 1), objectRetainedByReact = _a[0];\n    // Force update, see #2982\n    var _b = __read(React.useState(), 2), setState = _b[1];\n    var forceUpdate = function () { return setState([]); };\n    // StrictMode/ConcurrentMode/Suspense may mean that our component is\n    // rendered and abandoned multiple times, so we need to track leaked\n    // Reactions.\n    var reactionTrackingRef = React.useRef(null);\n    if (!reactionTrackingRef.current) {\n        // First render for this component (or first time since a previous\n        // reaction from an abandoned render was disposed).\n        var newReaction = new Reaction(observerComponentNameFor(baseComponentName), function () {\n            // Observable has changed, meaning we want to re-render\n            // BUT if we're a component that hasn't yet got to the useEffect()\n            // stage, we might be a component that _started_ to render, but\n            // got dropped, and we don't want to make state changes then.\n            // (It triggers warnings in StrictMode, for a start.)\n            if (trackingData_1.mounted) {\n                // We have reached useEffect(), so we're mounted, and can trigger an update\n                forceUpdate();\n            }\n            else {\n                // We haven't yet reached useEffect(), so we'll need to trigger a re-render\n                // when (and if) useEffect() arrives.\n                trackingData_1.changedBeforeMount = true;\n            }\n        });\n        var trackingData_1 = addReactionToTrack(reactionTrackingRef, newReaction, objectRetainedByReact);\n    }\n    var reaction = reactionTrackingRef.current.reaction;\n    React.useDebugValue(reaction, printDebugValue);\n    React.useEffect(function () {\n        // Called on first mount only\n        recordReactionAsCommitted(reactionTrackingRef);\n        if (reactionTrackingRef.current) {\n            // Great. We've already got our reaction from our render;\n            // all we need to do is to record that it's now mounted,\n            // to allow future observable changes to trigger re-renders\n            reactionTrackingRef.current.mounted = true;\n            // Got a change before first mount, force an update\n            if (reactionTrackingRef.current.changedBeforeMount) {\n                reactionTrackingRef.current.changedBeforeMount = false;\n                forceUpdate();\n            }\n        }\n        else {\n            // The reaction we set up in our render has been disposed.\n            // This can be due to bad timings of renderings, e.g. our\n            // component was paused for a _very_ long time, and our\n            // reaction got cleaned up\n            // Re-create the reaction\n            reactionTrackingRef.current = {\n                reaction: new Reaction(observerComponentNameFor(baseComponentName), function () {\n                    // We've definitely already been mounted at this point\n                    forceUpdate();\n                }),\n                mounted: true,\n                changedBeforeMount: false,\n                cleanAt: Infinity\n            };\n            forceUpdate();\n        }\n        return function () {\n            reactionTrackingRef.current.reaction.dispose();\n            reactionTrackingRef.current = null;\n        };\n    }, []);\n    // render the original component, but have the\n    // reaction track the observables, so that rendering\n    // can be invalidated (see above) once a dependency changes\n    var rendering;\n    var exception;\n    reaction.track(function () {\n        try {\n            rendering = fn();\n        }\n        catch (e) {\n            exception = e;\n        }\n    });\n    if (exception) {\n        throw exception; // re-throw any exceptions caught during rendering\n    }\n    return rendering;\n}\n//# sourceMappingURL=useObserver.js.map","var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { forwardRef, memo } from \"react\";\nimport { isUsingStaticRendering } from \"./staticRendering\";\nimport { useObserver } from \"./useObserver\";\n// n.b. base case is not used for actual typings or exported in the typing files\nexport function observer(baseComponent, options) {\n    // The working of observer is explained step by step in this talk: https://www.youtube.com/watch?v=cPF4iBedoF0&feature=youtu.be&t=1307\n    if (isUsingStaticRendering()) {\n        return baseComponent;\n    }\n    var realOptions = __assign({ forwardRef: false }, options);\n    var baseComponentName = baseComponent.displayName || baseComponent.name;\n    var wrappedComponent = function (props, ref) {\n        return useObserver(function () { return baseComponent(props, ref); }, baseComponentName);\n    };\n    wrappedComponent.displayName = baseComponentName;\n    // Support legacy context: `contextTypes` must be applied before `memo`       \n    if (baseComponent.contextTypes) {\n        wrappedComponent.contextTypes = baseComponent.contextTypes;\n    }\n    // memo; we are not interested in deep updates\n    // in props; we assume that if deep objects are changed,\n    // this is in observables, which would have been tracked anyway\n    var memoComponent;\n    if (realOptions.forwardRef) {\n        // we have to use forwardRef here because:\n        // 1. it cannot go before memo, only after it\n        // 2. forwardRef converts the function into an actual component, so we can't let the baseComponent do it\n        //    since it wouldn't be a callable function anymore\n        memoComponent = memo(forwardRef(wrappedComponent));\n    }\n    else {\n        memoComponent = memo(wrappedComponent);\n    }\n    copyStaticProperties(baseComponent, memoComponent);\n    memoComponent.displayName = baseComponentName;\n    if (\"production\" !== process.env.NODE_ENV) {\n        Object.defineProperty(memoComponent, 'contextTypes', {\n            set: function () {\n                throw new Error(\"[mobx-react-lite] `\" + (this.displayName || 'Component') + \".contextTypes` must be set before applying `observer`.\");\n            }\n        });\n    }\n    return memoComponent;\n}\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\nvar hoistBlackList = {\n    $$typeof: true,\n    render: true,\n    compare: true,\n    type: true\n};\nfunction copyStaticProperties(base, target) {\n    Object.keys(base).forEach(function (key) {\n        if (!hoistBlackList[key]) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));\n        }\n    });\n}\n//# sourceMappingURL=observer.js.map","import { useObserver } from \"./useObserver\";\nfunction ObserverComponent(_a) {\n    var children = _a.children, render = _a.render;\n    var component = children || render;\n    if (typeof component !== \"function\") {\n        return null;\n    }\n    return useObserver(component);\n}\nif (\"production\" !== process.env.NODE_ENV) {\n    ObserverComponent.propTypes = {\n        children: ObserverPropsCheck,\n        render: ObserverPropsCheck\n    };\n}\nObserverComponent.displayName = \"Observer\";\nexport { ObserverComponent as Observer };\nfunction ObserverPropsCheck(props, key, componentName, location, propFullName) {\n    var extraKey = key === \"children\" ? \"render\" : \"children\";\n    var hasProp = typeof props[key] === \"function\";\n    var hasExtraProp = typeof props[extraKey] === \"function\";\n    if (hasProp && hasExtraProp) {\n        return new Error(\"MobX Observer: Do not use children and render in the same time in`\" + componentName);\n    }\n    if (hasProp || hasExtraProp) {\n        return null;\n    }\n    return new Error(\"Invalid prop `\" +\n        propFullName +\n        \"` of type `\" +\n        typeof props[key] +\n        \"` supplied to\" +\n        \" `\" +\n        componentName +\n        \"`, expected `function`.\");\n}\n//# sourceMappingURL=ObserverComponent.js.map","import { observable } from \"mobx\";\nimport { useState } from \"react\";\nexport function useLocalObservable(initializer, annotations) {\n    return useState(function () { return observable(initializer(), annotations, { autoBind: true }); })[0];\n}\n//# sourceMappingURL=useLocalObservable.js.map","var __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nimport { useDeprecated } from \"./utils/utils\";\nimport { observable, runInAction } from \"mobx\";\nimport { useState } from \"react\";\nexport function useAsObservableSource(current) {\n    if (\"production\" !== process.env.NODE_ENV)\n        useDeprecated(\"[mobx-react-lite] 'useAsObservableSource' is deprecated, please store the values directly in an observable, for example by using 'useLocalObservable', and sync future updates using 'useEffect' when needed. See the README for examples.\");\n    var _a = __read(useState(function () { return observable(current, {}, { deep: false }); }), 1), res = _a[0];\n    runInAction(function () {\n        Object.assign(res, current);\n    });\n    return res;\n}\n//# sourceMappingURL=useAsObservableSource.js.map","import { observable } from \"mobx\";\nimport { useState } from \"react\";\nimport { useDeprecated } from \"./utils/utils\";\nimport { useAsObservableSource } from \"./useAsObservableSource\";\nexport function useLocalStore(initializer, current) {\n    if (\"production\" !== process.env.NODE_ENV)\n        useDeprecated(\"[mobx-react-lite] 'useLocalStore' is deprecated, use 'useLocalObservable' instead.\");\n    var source = current && useAsObservableSource(current);\n    return useState(function () { return observable(initializer(source), undefined, { autoBind: true }); })[0];\n}\n//# sourceMappingURL=useLocalStore.js.map","import \"./utils/assertEnvironment\";\nimport { unstable_batchedUpdates as batch } from \"./utils/reactBatchedUpdates\";\nimport { observerBatching } from \"./utils/observerBatching\";\nimport { useDeprecated } from \"./utils/utils\";\nimport { useObserver as useObserverOriginal } from \"./useObserver\";\nimport { enableStaticRendering } from \"./staticRendering\";\nobserverBatching(batch);\nexport { isUsingStaticRendering, enableStaticRendering } from \"./staticRendering\";\nexport { observer } from \"./observer\";\nexport { Observer } from \"./ObserverComponent\";\nexport { useLocalObservable } from \"./useLocalObservable\";\nexport { useLocalStore } from \"./useLocalStore\";\nexport { useAsObservableSource } from \"./useAsObservableSource\";\nexport { resetCleanupScheduleForTests as clearTimers } from \"./utils/reactionCleanupTracking\";\nexport function useObserver(fn, baseComponentName) {\n    if (baseComponentName === void 0) { baseComponentName = \"observed\"; }\n    if (\"production\" !== process.env.NODE_ENV) {\n        useDeprecated(\"[mobx-react-lite] 'useObserver(fn)' is deprecated. Use `<Observer>{fn}</Observer>` instead, or wrap the entire component in `observer`.\");\n    }\n    return useObserverOriginal(fn, baseComponentName);\n}\nexport { isObserverBatched, observerBatching } from \"./utils/observerBatching\";\nexport function useStaticRendering(enable) {\n    if (\"production\" !== process.env.NODE_ENV) {\n        console.warn(\"[mobx-react-lite] 'useStaticRendering' is deprecated, use 'enableStaticRendering' instead\");\n    }\n    enableStaticRendering(enable);\n}\n//# sourceMappingURL=index.js.map"],"names":["useState","Error","makeObservable","defaultNoopBatch","callback","observerBatching","reactionScheduler","configure","printDebugValue","v","getDependencyTree","FinalizationRegistryLocal","FinalizationRegistry","undefined","createTrackingData","reaction","mounted","changedBeforeMount","cleanAt","Date","now","CLEANUP_LEAKED_REACTIONS_AFTER_MILLIS","__values","o","s","Symbol","iterator","m","i","call","length","next","value","done","TypeError","_a","cleanupTokenToReactionTrackingMap","Map","globalCleanupTokensCounter","registry","token","trackedReaction","get","dispose","delete","addReactionToTrack","reactionTrackingRef","objectRetainedByReact","register","current","finalizationRegistryCleanupToken","set","recordReactionAsCommitted","reactionRef","unregister","forceCleanupTimerToRunNowForTests","resetCleanupScheduleForTests","createReactionCleanupTrackingUsingFinalizationRegister","reactionCleanupHandle","uncommittedReactionRefs","Set","ensureCleanupTimerRunning","setTimeout","cleanUncommittedReactions","forEach","ref","tracking","size","add","clearTimeout","e_1","uncommittedReactionRefs_1","uncommittedReactionRefs_1_1","e_1_1","error","return","clear","createTimerBasedReactionCleanupTracking","globalIsUsingStaticRendering","enableStaticRendering","enable","isUsingStaticRendering","__read","n","r","e","ar","push","observerComponentNameFor","baseComponentName","ObjectToBeRetainedByReact","objectToBeRetainedByReactFactory","useObserver","fn","setState","forceUpdate","newReaction","Reaction","trackingData_1","rendering","exception","Infinity","track","__assign","Object","assign","t","arguments","p","prototype","hasOwnProperty","apply","this","observer","baseComponent","options","memoComponent","base","target","realOptions","forwardRef","displayName","name","wrappedComponent","props","contextTypes","memo","keys","key","hoistBlackList","defineProperty","getOwnPropertyDescriptor","$$typeof","render","compare","type","ObserverComponent","children","component","useLocalObservable","initializer","annotations","observable","autoBind","useAsObservableSource","res","deep","runInAction","useLocalStore","source","useStaticRendering"],"sourceRoot":""}